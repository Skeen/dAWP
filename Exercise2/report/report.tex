\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{minted}

\author{
SÃ¸ren Krogh -  20105661 \\
Emil Madsen - 20105376  \\
K. Rohde Fischer - 20052356\\}
\title{}
\begin{document}
\maketitle

\section*{Introduction}


\section*{Embedded JavaScript}

\begin{minted}[linenos, frame=lines]{js}
  // The test object containing tests
  var testObject = {
    test1: function() { /* ... */ },
    test2: function() { /* ... */ }
    // ...
  }

  Object.defineProperty(testObject, "init", { dontenum: true })
\end{minted}


\section*{Object oriented hierarchy}
The simple inheritance hierachy is done by using the built in
prototype mechanism in JavaScript.  To test this a div box with the
outputs from the different calls has been created, as this creates the
simplest test bench possible.

It is possible to ensure that Pet can never be instantiated through
the one-shot closure:

\begin{minted}[linenos, frame=lines]{js}
  // Global scope variables
  // In actually they should probably be in a module
  var Dog;
  var Cat;

  function() {
    // This is a variable limited to the function scope.
    var Pet = function() { /* ... */ };

    Dog = function() { /* ... */ };
    Cat = function() { /* ... */ };
    Dog.prototype = new Pet()
    /* ... other prototype actions ... */
    Cat.prototype = new Pet()
    /* ... other prototype actions ... */
  }();
\end{minted}

For concealing the name property the only option is to create a
separate getName function for each subclass, thus eliminating the
smart practicality with inheritance.  This has been demonstrated in
the Dog class, but would be quite impractical in the long run.  The
solution require the usage of ``DontDelete'' ($configurable: false$)
and ``Read-only'' ($writable: false$).

The technique for making sound read-only is the same as for getName,
albeit more practical as they aren't defined on the inheritance level.

\section*{Fun Sorting Game}


\section*{Asynchronous loading}
\subsection*{XMLHttpRequest}
  XMLHttpRequrest(xhr) provides some security features e.g:
Same origin policy (sikkerhedspolitik). This tries to prevent cross domain attack and does not blindly parse code(You can still explicitly parse it). Thus it's still possible to implement the security errors.
Furthermore using xhr also gives acess to http statuses which can be used to provide better feedback.
A downside to xhr is that it can be rather tedious to code, but most libraries provide nice wrappers and if not using a library, it's fairly easy to code yourself.

\subsection*{iframe \& Script Tags}
Iframe and Script tags both have the advantage that they are rather light on code. On the other hand, neither iframe nor Script tags prevents cross origin attacks or execution of code. Usually this method is definitely not recomended but is in some cases used when browser permossions or similar prevents xhr. A common format in that case is JSONP.

\section*{Boss snooping}


\section*{JSLint}
The concept of validating JavaScript is justified because the interpretors operate by the "keep on trucking" philosophy. This in turn means that validation is limited at best. Thus JavaScript code is quite error prone and alot of pages have errors due to this fact.

The validation by JSLint is probably quite usefull, but seems to overly pedantic. For instance it require a whitespace in places where it has, and can never have, any semantic difference. 


\end{document}
